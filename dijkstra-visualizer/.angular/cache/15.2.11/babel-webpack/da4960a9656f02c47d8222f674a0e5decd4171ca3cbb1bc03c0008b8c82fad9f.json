{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"../../services/city-data.service\";\nimport * as i2 from \"@angular/common\";\nfunction GridComponent_li_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ÉµÉµelementStart(0, \"li\");\n    i0.ÉµÉµtext(1);\n    i0.ÉµÉµelementEnd();\n  }\n  if (rf & 2) {\n    const city_r1 = ctx.$implicit;\n    i0.ÉµÉµadvance(1);\n    i0.ÉµÉµtextInterpolate(city_r1.name);\n  }\n}\nexport class GridComponent {\n  constructor(cityDataService) {\n    this.cityDataService = cityDataService;\n    this.grid = [];\n    this.rows = 10;\n    this.cols = 10;\n    this.cities = [];\n    this.distances = [];\n  }\n  ngOnInit() {\n    this.cityDataService.getCityData().subscribe(data => {\n      this.cities = data.cities;\n      this.distances = data.distances;\n    });\n  }\n  initializeGrid() {\n    this.grid = Array.from({\n      length: this.rows\n    }, () => Array(this.cols).fill(1));\n  }\n  visualizeDijkstra() {\n    // Implement Dijkstra's algorithm here using this.cities and this.distances\n  }\n  visualizeDijkstraOld() {\n    // Implement Dijkstra's algorithm here\n    // Update the grid to reflect the shortest path\n    const start = [0, 0];\n    const end = [this.rows - 1, this.cols - 1];\n    const visited = Array.from({\n      length: this.rows\n    }, () => Array(this.cols).fill(false));\n    const distance = Array.from({\n      length: this.rows\n    }, () => Array(this.cols).fill(Infinity));\n    const previous = Array.from({\n      length: this.rows\n    }, () => Array(this.cols).fill(null));\n    distance[start[0]][start[1]] = 0;\n    const unvisited = [[...start]];\n    while (unvisited.length > 0) {\n      // Find the node with the smallest distance\n      const [currentRow, currentCol] = unvisited.pop();\n      if (visited[currentRow][currentCol]) continue;\n      visited[currentRow][currentCol] = true;\n      // Check neighbors\n      const neighbors = [[currentRow - 1, currentCol], [currentRow + 1, currentCol], [currentRow, currentCol - 1], [currentRow, currentCol + 1]];\n      for (const [neighborRow, neighborCol] of neighbors) {\n        if (neighborRow >= 0 && neighborRow < this.rows && neighborCol >= 0 && neighborCol < this.cols && !visited[neighborRow][neighborCol]) {\n          const alt = distance[currentRow][currentCol] + 1;\n          if (alt < distance[neighborRow][neighborCol]) {\n            distance[neighborRow][neighborCol] = alt;\n            previous[neighborRow][neighborCol] = [currentRow, currentCol];\n            unvisited.push([neighborRow, neighborCol]);\n          }\n        }\n      }\n    } // Reconstruct the shortest path\n    let path = [];\n    let current = end;\n    while (current) {\n      path.unshift(current);\n      current = previous[current[0]][current[1]];\n    }\n    // Update the grid to reflect the path\n    for (const [row, col] of path) {\n      this.grid[row][col] = 2;\n    }\n  }\n  static {\n    this.Éµfac = function GridComponent_Factory(t) {\n      return new (t || GridComponent)(i0.ÉµÉµdirectiveInject(i1.CityDataService));\n    };\n  }\n  static {\n    this.Éµcmp = /*@__PURE__*/i0.ÉµÉµdefineComponent({\n      type: GridComponent,\n      selectors: [[\"app-grid\"]],\n      decls: 7,\n      vars: 1,\n      consts: [[4, \"ngFor\", \"ngForOf\"], [3, \"click\"]],\n      template: function GridComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ÉµÉµelementStart(0, \"div\")(1, \"h2\");\n          i0.ÉµÉµtext(2, \"City Distance Visualizer\");\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµelementStart(3, \"ul\");\n          i0.ÉµÉµtemplate(4, GridComponent_li_4_Template, 2, 1, \"li\", 0);\n          i0.ÉµÉµelementEnd();\n          i0.ÉµÉµelementStart(5, \"button\", 1);\n          i0.ÉµÉµlistener(\"click\", function GridComponent_Template_button_click_5_listener() {\n            return ctx.visualizeDijkstra();\n          });\n          i0.ÉµÉµtext(6, \"Visualize Shortest Path\");\n          i0.ÉµÉµelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ÉµÉµadvance(4);\n          i0.ÉµÉµproperty(\"ngForOf\", ctx.cities);\n        }\n      },\n      dependencies: [i2.NgForOf],\n      styles: [\".grid[_ngcontent-%COMP%] {\\n  display: grid;\\n  grid-template-rows: repeat(10, 30px);\\n  grid-template-columns: repeat(10, 30px);\\n  gap: 1px;\\n}\\n.row[_ngcontent-%COMP%] {\\n  display: contents;\\n}\\n.cell[_ngcontent-%COMP%] {\\n  width: 30px;\\n  height: 30px;\\n  background-color: lightgray;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\nstart[_ngcontent-%COMP%] {\\n    background-color: green;\\n  }\\n  \\n  .end[_ngcontent-%COMP%] {\\n    background-color: red;\\n  }\\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL3NyYy9hcHAvY29tcG9uZW50cy9ncmlkL2dyaWQuY29tcG9uZW50LmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7RUFDRSxhQUFhO0VBQ2Isb0NBQW9DO0VBQ3BDLHVDQUF1QztFQUN2QyxRQUFRO0FBQ1Y7QUFDQTtFQUNFLGlCQUFpQjtBQUNuQjtBQUNBO0VBQ0UsV0FBVztFQUNYLFlBQVk7RUFDWiwyQkFBMkI7RUFDM0IsYUFBYTtFQUNiLHVCQUF1QjtFQUN2QixtQkFBbUI7QUFDckI7QUFDQTtJQUNJLHVCQUF1QjtFQUN6Qjs7RUFFQTtJQUNFLHFCQUFxQjtFQUN2QiIsInNvdXJjZXNDb250ZW50IjpbIlxuLmdyaWQge1xuICBkaXNwbGF5OiBncmlkO1xuICBncmlkLXRlbXBsYXRlLXJvd3M6IHJlcGVhdCgxMCwgMzBweCk7XG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDEwLCAzMHB4KTtcbiAgZ2FwOiAxcHg7XG59XG4ucm93IHtcbiAgZGlzcGxheTogY29udGVudHM7XG59XG4uY2VsbCB7XG4gIHdpZHRoOiAzMHB4O1xuICBoZWlnaHQ6IDMwcHg7XG4gIGJhY2tncm91bmQtY29sb3I6IGxpZ2h0Z3JheTtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG5zdGFydCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogZ3JlZW47XG4gIH1cbiAgXG4gIC5lbmQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJlZDtcbiAgfSJdLCJzb3VyY2VSb290IjoiIn0= */\"]\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["i0","GridComponent","constructor","cityDataService","ngOnInit","getCityData","subscribe","data","cities","distances","initializeGrid","grid","Array","from","length","rows","cols","fill","visualizeDijkstra","visualizeDijkstraOld","start","end","visited","distance","Infinity","previous","unvisited","currentRow","currentCol","pop","neighbors","neighborRow","neighborCol","alt","push","path","current","unshift","row","col","selectors","decls","vars","consts","template","ctx"],"sourceRoot":"","sources":["/Users/shantanu/Documents/meimalai/dijkstra-visualizer/src/app/components/grid/grid.component.html","/Users/shantanu/Documents/meimalai/dijkstra-visualizer/src/app/components/grid/grid.component.ts"],"sourcesContent":["<!-- <div class=\"grid\">\n    <div *ngFor=\"let row of grid; let i = index\" class=\"row\">\n      <div *ngFor=\"let cell of row; let j = index\" \n  class=\"cell\" [ngClass]=\"{'start': i === 0 && j === 0, 'end': i === rows - 1 \n  && j === cols - 1}\">\n        {{ cell }}\n      </div>\n    </div>\n  </div>\n  ðŸŽ¨\n\n  <button (click)=\"visualizeDijkstra()\">Visualize Dijkstra</button>\n-->\n  <div>\n  <h2>City Distance Visualizer</h2>\n  <ul>\n    <li *ngFor=\"let city of cities\">{{ city.name }}</li>\n  </ul>\n  <button (click)=\"visualizeDijkstra()\">Visualize Shortest Path</button>\n</div>","import { Component } from '@angular/core';\n\nimport { CityDataService } from '../../services/city-data.service';\n@Component({\n  selector: 'app-grid',\n  templateUrl: './grid.component.html',\n  styleUrls: ['./grid.component.css']\n})\nexport class GridComponent {\n  \n    grid: number[][] = [];\n    rows: number = 10;\n    cols: number = 10;\n    cities: any[] = [];\n  distances: number[][] = [];\n    constructor(private cityDataService: CityDataService) { }\n  ngOnInit(): void {\n    this.cityDataService.getCityData().subscribe(data => {\n      this.cities = data.cities;\n      this.distances = data.distances;\n    });\n  }\n    initializeGrid(): void {\n      this.grid = Array.from({ length: this.rows }, () => Array(this.cols).fill(1));\n    }\n    visualizeDijkstra(): void {\n      // Implement Dijkstra's algorithm here using this.cities and this.distances\n    }\n    visualizeDijkstraOld(): void {\n      // Implement Dijkstra's algorithm here\n      // Update the grid to reflect the shortest path\n      const start = [0, 0];\n      const end = [this.rows - 1, this.cols - 1];\n      const visited = Array.from({ length: this.rows }, () => Array(this.cols).fill(false));\n      const distance = Array.from({ length: this.rows }, () => Array(this.cols).fill(Infinity));\n      const previous = Array.from({ length: this.rows }, () => Array(this.cols).fill(null));\n    \n      distance[start[0]][start[1]] = 0;\n    \n      const unvisited = [[...start]];while (unvisited.length > 0) {\n        // Find the node with the smallest distance\n        const [currentRow, currentCol] = unvisited.pop()!;\n        if (visited[currentRow][currentCol]) continue;\n    \n        visited[currentRow][currentCol] = true;\n    \n        // Check neighbors\n        const neighbors = [\n          [currentRow - 1, currentCol],\n          [currentRow + 1, currentCol],\n          [currentRow, currentCol - 1],\n          [currentRow, currentCol + 1]\n        ];\n    \n        for (const [neighborRow, neighborCol] of neighbors) {\n          if (\n            neighborRow >= 0 && neighborRow < this.rows &&\n            neighborCol >= 0 && neighborCol < this.cols &&\n            !visited[neighborRow][neighborCol]\n          ) {\n            const alt = distance[currentRow][currentCol] + 1;\n            if (alt < distance[neighborRow][neighborCol]) {\n              distance[neighborRow][neighborCol] = alt;\n              previous[neighborRow][neighborCol] = [currentRow, currentCol];\n              unvisited.push([neighborRow, neighborCol]);\n            }\n          }\n        }\n          }// Reconstruct the shortest path\n        let path = [];\n        let current = end;\n        while (current) {\n          path.unshift(current);\n          current = previous[current[0]][current[1]];\n        }\n\n        // Update the grid to reflect the path\n        for (const [row, col] of path) {\n          this.grid[row][col] = 2;\n        }\n      }\n  }\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}