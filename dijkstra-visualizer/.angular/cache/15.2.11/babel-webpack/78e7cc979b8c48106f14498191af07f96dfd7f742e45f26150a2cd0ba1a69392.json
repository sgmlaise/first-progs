{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"../../services/city-data.service\";\nimport * as i2 from \"@angular/common\";\nconst _c0 = function (a0, a1, a2) {\n  return {\n    \"start\": a0,\n    \"end\": a1,\n    \"highlight\": a2\n  };\n};\nfunction GridComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 8);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const cell_r4 = ctx.$implicit;\n    const k_r5 = ctx.index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction3(2, _c0, k_r5 === 0, k_r5 === 7, ctx_r0.shortestPath.includes(cell_r4.name)));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", cell_r4.name, \" \");\n  }\n}\nconst _c1 = function (a0, a1) {\n  return {\n    \"start\": a0,\n    \"end\": a1\n  };\n};\nfunction GridComponent_div_5_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 8);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const cell_r9 = ctx.$implicit;\n    const j_r10 = ctx.index;\n    const i_r7 = i0.ɵɵnextContext().index;\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction2(2, _c1, i_r7 === 0 && j_r10 === 0, i_r7 === ctx_r8.rows - 1 && j_r10 === ctx_r8.cols - 1));\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", cell_r9, \" \");\n  }\n}\nfunction GridComponent_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 1)(1, \"div\", 2);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, GridComponent_div_5_div_3_Template, 2, 5, \"div\", 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const row_r6 = ctx.$implicit;\n    const i_r7 = ctx.index;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(ctx_r1.cities[i_r7].name);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", row_r6);\n  }\n}\nfunction GridComponent_option_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"option\", 9);\n    i0.ɵɵlistener(\"change\", function GridComponent_option_7_Template_option_change_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r15);\n      const i_r13 = restoredCtx.index;\n      const ctx_r14 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r14.getId(i_r13));\n    });\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const city_r12 = ctx.$implicit;\n    i0.ɵɵproperty(\"value\", city_r12.id);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", city_r12.name, \" \");\n  }\n}\nfunction GridComponent_li_15_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const city_r16 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(city_r16.name);\n  }\n}\nexport class GridComponent {\n  getId(Id) {}\n  constructor(cityDataService) {\n    this.cityDataService = cityDataService;\n    this.grid = [];\n    this.rows = 8;\n    this.cols = 8;\n    this.shortestPath = [];\n    this.cities = [];\n    this.distances = [];\n    this.selectedStart = '0';\n    this.initializeGrid();\n  }\n  initializeGrid() {\n    this.cityDataService.getCityData().subscribe(data => {\n      this.cities = data.cities;\n      this.distances = data.distances;\n      this.grid = Array.from(this.distances, row => Array.from(row));\n    });\n    //   this.grid = Array.from({ length: this.rows }, () => Array(this.cols).fill(1));\n  }\n\n  ngOnInit() {\n    this.cityDataService.getCityData().subscribe(data => {\n      this.cities = data.cities;\n      this.distances = data.distances;\n    });\n  }\n  visualizeDijkstra() {\n    // Implement Dijkstra's algorithm here using this.cities and this.distances\n    const startCityIndex = 0; // Index of the starting city\n    const endCityIndex = 5; // Index of the destination city\n    // Initialize distances and previous nodes\n    const distances = Array(this.cities.length).fill(Infinity);\n    const previousNodes = Array(this.cities.length).fill(null);\n    const unvisitedCities = new Set(this.cities.map((_, index) => index));\n    distances[startCityIndex] = 0;\n    while (unvisitedCities.size > 0) {\n      // Find the unvisited city with the smallest distance\n      let currentCityIndex = -1;\n      let smallestDistance = Infinity;\n      console.log('smallest distance: unvisited cities');\n      unvisitedCities.forEach(cityIndex => {\n        if (distances[cityIndex] < smallestDistance) {\n          smallestDistance = distances[cityIndex];\n          currentCityIndex = cityIndex;\n          console.log(`smallest distance: ${smallestDistance}, city ${this.cities[cityIndex].name}`);\n        }\n      });\n      // If the smallest distance is infinity, there's no path\n      if (smallestDistance === Infinity) {\n        break;\n      }\n      // Remove the current city from the unvisited set\n      unvisitedCities.delete(currentCityIndex);\n      // Update distances for neighboring cities\n      this.cities.forEach((_, neighborIndex) => {\n        if (neighborIndex !== currentCityIndex && unvisitedCities.has(neighborIndex)) {\n          const distance = this.distances[currentCityIndex][neighborIndex];\n          const newDistance = distances[currentCityIndex] + distance;\n          if (newDistance < distances[neighborIndex]) {\n            distances[neighborIndex] = newDistance;\n            previousNodes[neighborIndex] = currentCityIndex;\n          }\n        }\n      });\n    }\n    // Reconstruct the shortest path\n    const path = [];\n    let currentCityIndex = endCityIndex;\n    while (currentCityIndex !== null) {\n      path.unshift(this.cities[currentCityIndex].name);\n      currentCityIndex = previousNodes[currentCityIndex];\n    }\n    this.shortestPath = [...path];\n    // Display the shortest path and its distance\n    console.log('Shortest path:', path.join(' -> '));\n    console.log('Total distance:', distances[endCityIndex]);\n  }\n  visualizeDijkstraOld() {\n    // Implement Dijkstra's algorithm here\n    // Update the grid to reflect the shortest path\n    const start = [0, 0];\n    const end = [this.rows - 1, this.cols - 1];\n    const visited = Array.from({\n      length: this.rows\n    }, () => Array(this.cols).fill(false));\n    const distance = Array.from({\n      length: this.rows\n    }, () => Array(this.cols).fill(Infinity));\n    const previous = Array.from({\n      length: this.rows\n    }, () => Array(this.cols).fill(null));\n    distance[start[0]][start[1]] = 0;\n    const unvisited = [[...start]];\n    while (unvisited.length > 0) {\n      // Find the node with the smallest distance\n      const [currentRow, currentCol] = unvisited.pop();\n      if (visited[currentRow][currentCol]) continue;\n      visited[currentRow][currentCol] = true;\n      // Check neighbors\n      const neighbors = [[currentRow - 1, currentCol], [currentRow + 1, currentCol], [currentRow, currentCol - 1], [currentRow, currentCol + 1]];\n      for (const [neighborRow, neighborCol] of neighbors) {\n        if (neighborRow >= 0 && neighborRow < this.rows && neighborCol >= 0 && neighborCol < this.cols && !visited[neighborRow][neighborCol]) {\n          const alt = distance[currentRow][currentCol] + 1;\n          if (alt < distance[neighborRow][neighborCol]) {\n            distance[neighborRow][neighborCol] = alt;\n            previous[neighborRow][neighborCol] = [currentRow, currentCol];\n            unvisited.push([neighborRow, neighborCol]);\n          }\n        }\n      }\n    } // Reconstruct the shortest path\n    let path = [];\n    let current = end;\n    while (current) {\n      path.unshift(current);\n      current = previous[current[0]][current[1]];\n    }\n    // Update the grid to reflect the path\n    for (const [row, col] of path) {\n      this.grid[row][col] = 2;\n    }\n  }\n  get ShortestPath() {\n    return JSON.stringify(this.shortestPath);\n  }\n  static {\n    this.ɵfac = function GridComponent_Factory(t) {\n      return new (t || GridComponent)(i0.ɵɵdirectiveInject(i1.CityDataService));\n    };\n  }\n  static {\n    this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: GridComponent,\n      selectors: [[\"app-grid\"]],\n      decls: 18,\n      vars: 5,\n      consts: [[1, \"grid\"], [1, \"row\"], [1, \"cell\"], [\"class\", \"cell\", 3, \"ngClass\", 4, \"ngFor\", \"ngForOf\"], [\"class\", \"row\", 4, \"ngFor\", \"ngForOf\"], [3, \"value\", \"change\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"], [4, \"ngFor\", \"ngForOf\"], [1, \"cell\", 3, \"ngClass\"], [3, \"value\", \"change\"]],\n      template: function GridComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1)(2, \"div\", 2);\n          i0.ɵɵtext(3, \"\\u00A0\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵtemplate(4, GridComponent_div_4_Template, 2, 6, \"div\", 3);\n          i0.ɵɵtemplate(5, GridComponent_div_5_Template, 4, 2, \"div\", 4);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(6, \"select\");\n          i0.ɵɵtemplate(7, GridComponent_option_7_Template, 2, 2, \"option\", 5);\n          i0.ɵɵelementEnd();\n          i0.ɵɵtext(8);\n          i0.ɵɵelementStart(9, \"button\", 6);\n          i0.ɵɵlistener(\"click\", function GridComponent_Template_button_click_9_listener() {\n            return ctx.visualizeDijkstra();\n          });\n          i0.ɵɵtext(10, \"Visualize Dijkstra\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(11, \"div\", 0)(12, \"h2\");\n          i0.ɵɵtext(13, \"City Distance Visualizer\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(14, \"ul\");\n          i0.ɵɵtemplate(15, GridComponent_li_15_Template, 2, 1, \"li\", 7);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(16, \"button\", 6);\n          i0.ɵɵlistener(\"click\", function GridComponent_Template_button_click_16_listener() {\n            return ctx.visualizeDijkstra();\n          });\n          i0.ɵɵtext(17, \"Visualize Shortest Path\");\n          i0.ɵɵelementEnd()()();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(4);\n          i0.ɵɵproperty(\"ngForOf\", ctx.cities);\n          i0.ɵɵadvance(1);\n          i0.ɵɵproperty(\"ngForOf\", ctx.grid);\n          i0.ɵɵadvance(2);\n          i0.ɵɵproperty(\"ngForOf\", ctx.cities);\n          i0.ɵɵadvance(1);\n          i0.ɵɵtextInterpolate1(\" \", ctx.ShortestPath, \" \");\n          i0.ɵɵadvance(7);\n          i0.ɵɵproperty(\"ngForOf\", ctx.cities);\n        }\n      },\n      dependencies: [i2.NgClass, i2.NgForOf],\n      styles: [\".grid[_ngcontent-%COMP%] {\\n  display: grid;\\n  grid-template-rows: repeat(8, 40px);\\n  grid-template-columns: repeat(9, 70px);\\n  gap: 1px;\\n}\\n.row[_ngcontent-%COMP%] {\\n  display: contents;\\n}\\n.cell[_ngcontent-%COMP%] {\\n  width: 70px;\\n  height: 30px;\\n  background-color: lightgray;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  margin: 30px;\\n  border: 2px gray outset ;\\n  \\n}\\n\\n.extendedCell[_ngcontent-%COMP%] {\\n    width: 140px;\\n    height: 30px;\\n    background-color: lightgray;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    margin: 30px;\\n    border: 2px gray outset ;\\n    \\n  }\\nstart[_ngcontent-%COMP%] {\\n    background-color: green;\\n  }\\n  \\n  .end[_ngcontent-%COMP%] {\\n    background-color: red;\\n  }\\n  .highlight[_ngcontent-%COMP%] {\\n    background-color: yellow;\\n    font-weight: bold;\\n  }\\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL3NyYy9hcHAvY29tcG9uZW50cy9ncmlkL2dyaWQuY29tcG9uZW50LmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0E7RUFDRSxhQUFhO0VBQ2IsbUNBQW1DO0VBQ25DLHNDQUFzQztFQUN0QyxRQUFRO0FBQ1Y7QUFDQTtFQUNFLGlCQUFpQjtBQUNuQjtBQUNBO0VBQ0UsV0FBVztFQUNYLFlBQVk7RUFDWiwyQkFBMkI7RUFDM0IsYUFBYTtFQUNiLHVCQUF1QjtFQUN2QixtQkFBbUI7RUFDbkIsWUFBWTtFQUNaLHdCQUF3Qjs7QUFFMUI7O0FBRUE7SUFDSSxZQUFZO0lBQ1osWUFBWTtJQUNaLDJCQUEyQjtJQUMzQixhQUFhO0lBQ2IsdUJBQXVCO0lBQ3ZCLG1CQUFtQjtJQUNuQixZQUFZO0lBQ1osd0JBQXdCOztFQUUxQjtBQUNGO0lBQ0ksdUJBQXVCO0VBQ3pCOztFQUVBO0lBQ0UscUJBQXFCO0VBQ3ZCO0VBQ0E7SUFDRSx3QkFBd0I7SUFDeEIsaUJBQWlCO0VBQ25CIiwic291cmNlc0NvbnRlbnQiOlsiXG4uZ3JpZCB7XG4gIGRpc3BsYXk6IGdyaWQ7XG4gIGdyaWQtdGVtcGxhdGUtcm93czogcmVwZWF0KDgsIDQwcHgpO1xuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg5LCA3MHB4KTtcbiAgZ2FwOiAxcHg7XG59XG4ucm93IHtcbiAgZGlzcGxheTogY29udGVudHM7XG59XG4uY2VsbCB7XG4gIHdpZHRoOiA3MHB4O1xuICBoZWlnaHQ6IDMwcHg7XG4gIGJhY2tncm91bmQtY29sb3I6IGxpZ2h0Z3JheTtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIG1hcmdpbjogMzBweDtcbiAgYm9yZGVyOiAycHggZ3JheSBvdXRzZXQgO1xuICBcbn1cblxuLmV4dGVuZGVkQ2VsbCB7XG4gICAgd2lkdGg6IDE0MHB4O1xuICAgIGhlaWdodDogMzBweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBsaWdodGdyYXk7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIG1hcmdpbjogMzBweDtcbiAgICBib3JkZXI6IDJweCBncmF5IG91dHNldCA7XG4gICAgXG4gIH1cbnN0YXJ0IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBncmVlbjtcbiAgfVxuICBcbiAgLmVuZCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmVkO1xuICB9XG4gIC5oaWdobGlnaHQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHllbGxvdztcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgfSJdLCJzb3VyY2VSb290IjoiIn0= */\"]\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["i0","GridComponent","getId","Id","constructor","cityDataService","initializeGrid","getCityData","subscribe","data","cities","distances","grid","Array","from","row","ngOnInit","visualizeDijkstra","startCityIndex","endCityIndex","length","fill","Infinity","previousNodes","unvisitedCities","Set","map","_","index","size","currentCityIndex","smallestDistance","console","log","forEach","cityIndex","name","delete","neighborIndex","has","distance","newDistance","path","unshift","shortestPath","join","visualizeDijkstraOld","start","end","rows","cols","visited","previous","unvisited","currentRow","currentCol","pop","neighbors","neighborRow","neighborCol","alt","push","current","col","ShortestPath","JSON","stringify","selectors","decls","vars","consts","template","ctx"],"sourceRoot":"","sources":["/Users/shantanu/Documents/meimalai/dijkstra-visualizer/src/app/components/grid/grid.component.html","/Users/shantanu/Documents/meimalai/dijkstra-visualizer/src/app/components/grid/grid.component.ts"],"sourcesContent":[" <div class=\"grid\">\n   <div class=\"row\">\n    <div class=\"cell\" >&nbsp;</div>\n    <!-- [ngClass]=\"{'highlight': shortestPath.includes(city.name)}\"-->\n    <div *ngFor=\"let cell of cities; let k = index\" \n    \n    class=\"cell\" [ngClass]=\"{'start': k === 0 , 'end': k === 7, 'highlight': shortestPath.includes(cell .name) }\">\n           {{ cell.name }}\n    </div>\n    <div *ngFor=\"let row of grid; let i = index\" class=\"row\">\n      <div class=\"cell\" >{{cities[i].name}}</div>\n      <div *ngFor=\"let cell of row; let j = index\" \n  class=\"cell\" [ngClass]=\"{'start': i === 0 && j === 0, 'end': i === rows - 1 \n  && j === cols - 1}\">\n         {{ cell }}\n      </div>\n    </div>\n  </div>\n  <select> \n    <option *ngFor=\"let city of cities; let i = index\" [value]=\"city.id\" (change)=\"getId(i)\">\n        {{city.name}}\n    </option>\n  </select>\n  {{ShortestPath}}\n\n  <button (click)=\"visualizeDijkstra()\">Visualize Dijkstra</button>\n  <div class=\"grid\">\n  <h2>City Distance Visualizer</h2>\n  <ul>\n    <li *ngFor=\"let city of cities\">{{ city.name }}</li>\n  </ul>\n  <button (click)=\"visualizeDijkstra()\">Visualize Shortest Path</button>\n</div>","import { Component } from '@angular/core';\nimport { CityDataService } from '../../services/city-data.service';\n\n@Component({\n  selector: 'app-grid',\n  templateUrl: './grid.component.html',\n  styleUrls: ['./grid.component.css']\n})\nexport class GridComponent {\n  \n    grid: number[][] = [];\n    rows: number = 8;\n    cols: number = 8;\n   \n   shortestPath:any = [] ;\n    cities: any[] = [];\n  distances: number[][] = [];\n  selectedStart = '0';\n  getId(Id:any) {\n\n  }\n    constructor(private cityDataService: CityDataService) {\n      this.initializeGrid();\n    }\n    initializeGrid(): void {\n      this.cityDataService.getCityData().subscribe(data => {\n        this.cities = data.cities;\n        this.distances = data.distances;\n        this.grid =  Array.from(this.distances,row => Array.from(row));\n   \n      });\n   //   this.grid = Array.from({ length: this.rows }, () => Array(this.cols).fill(1));\n      \n\n    }\n    ngOnInit(): void {\n      this.cityDataService.getCityData().subscribe(data => {\n        this.cities = data.cities;\n        this.distances = data.distances;\n      });\n      \n    }\n    visualizeDijkstra(): void {\n      // Implement Dijkstra's algorithm here using this.cities and this.distances\n      const startCityIndex = 0; // Index of the starting city\n  const endCityIndex = 5;   // Index of the destination city\n\n  // Initialize distances and previous nodes\n  const distances = Array(this.cities.length).fill(Infinity);\n  const previousNodes = Array(this.cities.length).fill(null);\n  const unvisitedCities = new Set(this.cities.map((_, index) => index));\n  distances[startCityIndex] = 0;\n\n  while (unvisitedCities.size > 0) {\n    // Find the unvisited city with the smallest distance\n    let currentCityIndex = -1;\n    let smallestDistance = Infinity;\n    console.log('smallest distance: unvisited cities');\n    unvisitedCities.forEach((cityIndex) => {\n      if (distances[cityIndex] < smallestDistance) {\n        smallestDistance = distances[cityIndex];\n        currentCityIndex = cityIndex;\n        console.log(`smallest distance: ${smallestDistance}, city ${this.cities[cityIndex].name}`);\n   \n      }\n    });\n\n    // If the smallest distance is infinity, there's no path\n    if (smallestDistance === Infinity) {\n      break;\n    }\n\n    // Remove the current city from the unvisited set\n    unvisitedCities.delete(currentCityIndex);\n\n    // Update distances for neighboring cities\n    this.cities.forEach((_, neighborIndex) => {\n      if (neighborIndex !== currentCityIndex && unvisitedCities.has(neighborIndex)) {\n        const distance = this.distances[currentCityIndex][neighborIndex];\n        const newDistance = distances[currentCityIndex] + distance;\n\n        if (newDistance < distances[neighborIndex]) {\n          distances[neighborIndex] = newDistance;\n          previousNodes[neighborIndex] = currentCityIndex;\n        }\n      }\n    });\n  }\n\n  // Reconstruct the shortest path\n  const path = [];\n  let currentCityIndex = endCityIndex;\n\n  while (currentCityIndex !== null) {\n    path.unshift(this.cities[currentCityIndex].name);\n    currentCityIndex = previousNodes[currentCityIndex];\n  }\n  this.shortestPath = [...path];\n  // Display the shortest path and its distance\n  console.log('Shortest path:', path.join(' -> '));\n  console.log('Total distance:', distances[endCityIndex]);\n    }\n    visualizeDijkstraOld(): void {\n      // Implement Dijkstra's algorithm here\n      // Update the grid to reflect the shortest path\n      const start = [0, 0];\n      const end = [this.rows - 1, this.cols - 1];\n      const visited = Array.from({ length: this.rows }, () => Array(this.cols).fill(false));\n      const distance = Array.from({ length: this.rows }, () => Array(this.cols).fill(Infinity));\n      const previous = Array.from({ length: this.rows }, () => Array(this.cols).fill(null));\n    \n      distance[start[0]][start[1]] = 0;\n    \n      const unvisited = [[...start]];while (unvisited.length > 0) {\n        // Find the node with the smallest distance\n        const [currentRow, currentCol] = unvisited.pop()!;\n        if (visited[currentRow][currentCol]) continue;\n    \n        visited[currentRow][currentCol] = true;\n    \n        // Check neighbors\n        const neighbors = [\n          [currentRow - 1, currentCol],\n          [currentRow + 1, currentCol],\n          [currentRow, currentCol - 1],\n          [currentRow, currentCol + 1]\n        ];\n    \n        for (const [neighborRow, neighborCol] of neighbors) {\n          if (\n            neighborRow >= 0 && neighborRow < this.rows &&\n            neighborCol >= 0 && neighborCol < this.cols &&\n            !visited[neighborRow][neighborCol]\n          ) {\n            const alt = distance[currentRow][currentCol] + 1;\n            if (alt < distance[neighborRow][neighborCol]) {\n              distance[neighborRow][neighborCol] = alt;\n              previous[neighborRow][neighborCol] = [currentRow, currentCol];\n              unvisited.push([neighborRow, neighborCol]);\n            }\n          }\n        }\n        }// Reconstruct the shortest path\n      let path = [];\n      let current = end;\n      while (current) {\n        path.unshift(current);\n        current = previous[current[0]][current[1]];\n      }\n\n      // Update the grid to reflect the path\n      for (const [row, col] of path) {\n        this.grid[row][col] = 2;\n      }\n    }\n    get ShortestPath():string {\n      return JSON.stringify(this.shortestPath)\n    }\n  }\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}